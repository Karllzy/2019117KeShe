C51 COMPILER V9.01   MAIN                                                                  01/07/2019 15:52:55 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "reg52.h"
   2          #include "absacc.h"
   3          
   4          typedef unsigned int u16;
   5          typedef unsigned char u8;
   6          
   7          u8      receiveCounter=0, sendCounter=0;                                                        //ç”¨äºæ¥å—å’Œå‘é€çš„å¯„å­˜å™¨
   8          u8      receiveBuff[7] = {0x55, 0xff, 0xC5, 0x00, 0x00, 0xAA, 0xff};    //å‘é€æ ¼å¼ä¸º:55, åœ°å€, CH5, æ•°æ®é
             -«˜, æ•°æ®ä½, æ ¡éªŒç (é«˜å››ä½æ— æ•ˆ)
   9          u8      sendBuff[5] = {0x55, 0xff, 0xEE, 0xAA, 0xff};                           //å¤±è´¥æŠ¥é”™æ ¼å¼ä¸º:55, åœ°å€ï¼Œ EEHï¼Œ AA, æ ¡éª
             -Œç 
  10          u8      motors1=0x00, motors2=0x00;
  11          
  12          void UsartInit();
  13          u8 readSwitch();
  14          u8 getCheckCode(u8 receive_or_send);
  15          
  16          void  main()
  17          {
  18   1              UsartInit();
  19   1              //InitTimer0()  æš‚æ—¶æ²¡æœ‰å¿…è¦ä½¿ç”¨
  20   1              while(1)
  21   1              {
  22   2                      P1 = motors1;
  23   2                      P2 = motors2 | 0xf0;                                                                    //ä½¿å¾—é«˜4ä½å…¨éƒ¨ç½®ä¸º1ï¼Œé¿å…å½±å“å…¶ä»–å¤–è®¾
  24   2              }                                               
  25   1      }
  26          /*******************************************************************************
  27          * å‡½æ•°å         :UsartInit()
  28          * å‡½æ•°åŠŸèƒ½           :åˆå§‹åŒ–ä¸²å£ä¸­æ–­
  29          * è¾“å…¥           : æ— 
  30          * è¾“å‡º                 : æ— 
  31          *******************************************************************************/
  32          void UsartInit()
  33          {
  34   1              EA = 1;                     //æ‰“å¼€ä¸­æ–­æ€»å¼€å…³
  35   1              ET1 = 1;                        //å…è®¸å®šæ—¶å™¨1ä¸­æ–­
  36   1              TMOD=0X21;                      //è®¾ç½®å®šæ—¶å™¨1ä¸ºå·¥ä½œæ–¹å¼2ï¼Œï¼ˆå®šæ—¶å™¨0ä¸ºå·¥ä½œæ–¹å¼1ï¼‰
  37   1              PCON=0X00;                      //æ³¢ç‰¹ç‡ä¸åŠ å€ï¼ˆSMODç½®ä¸º0ï¼‰
  38   1      
  39   1              TH1=0XFD;                       //è®¾ç½®æ³¢ç‰¹ç‡ä¸º9600bps
  40   1              TL1=0XFD;                       
  41   1              TR1=1;                          //å¼€å§‹å®šæ—¶
  42   1      }
  43          
  44          
  45          /*******************************************************************************
  46          * å‡½æ•°å         : Usart() interrupt 4
  47          * å‡½æ•°åŠŸèƒ½           : ä¸²å£é€šä¿¡ä¸­æ–­å‡½æ•°
  48          * è¾“å…¥           : æ— 
  49          * è¾“å‡º                 : æ— 
  50          *******************************************************************************/
  51          void Usart() interrupt 4
  52          {
  53   1              if(RI)
C51 COMPILER V9.01   MAIN                                                                  01/07/2019 15:52:55 PAGE 2   

  54   1              {
  55   2                      switch(receiveCounter)
  56   2                      {
  57   3                              case 0:                                                                                 //å¦‚æœæ˜¯ç¬¬1ä½, å…ˆè¿›è¡Œåè®®ç¡®è®¤,åè®®é”™è¯¯ï¼Œç›´æ¥æ”¾å¼ƒ
  58   3                                      if(SBUF==0x55)
  59   3                                      {
  60   4                                              receiveBuff[receiveCounter] = SBUF;
  61   4                                              receiveCounter++ ;
  62   4                                      }
  63   3                                      else
  64   3                                      {
  65   4                                              receiveCounter = 0;
  66   4                                      }
  67   3                                      break;
  68   3      
  69   3                              case 1:                                                                                 //å¦‚æœæ˜¯ç¬¬2ä½ï¼Œè¿›è¡Œåœ°å€ç¡®è®¤ï¼Œå¦‚æœåœ°å€ç¡®è®¤å¤±è´¥ï¼Œç›´æ¥æ”¾å¼ƒ
  70   3                                      if (SBUF == readSwitch())
  71   3                                      {
  72   4                                              receiveBuff[receiveCounter] = SBUF;
  73   4                                              receiveCounter++ ;
  74   4                                      }
  75   3                                      else
  76   3                                      {
  77   4                                              receiveCounter = 0 ;
  78   4                                      }
  79   3                                      break;
  80   3      
  81   3                              case 2:                                                                                 //å¦‚æœæ˜¯ç¬¬3ä½ï¼Œçœ‹çœ‹æŒ‡ä»¤å¯¹ä¸å¯¹ï¼Œå¦‚æœæŒ‡ä»¤é”™äº†ï¼Œä¸ä»…æ”¾å¼ƒè¿˜è¦å
             -‘é€é”™è¯¯æŠ¥å‘Š
  82   3                                      if (SBUF == 0xC5)
  83   3                                      {
  84   4                                              receiveBuff[receiveCounter] = SBUF;
  85   4                                              receiveCounter++ ;      
  86   4                                      }
  87   3                                      else
  88   3                                      {
  89   4                                              SBUF = sendBuff[sendCounter] ;
  90   4                                              receiveCounter = 0 ;//æ”¾å¼ƒæ­¤æ¬¡æ¥æ”¶æ•°æ®
  91   4                                              sendCounter++ ;
  92   4                                      }
  93   3                                      break;
  94   3                              case 3:                                                                                 //å¦‚æœæ˜¯ç¬¬4ä½ç›´æ¥æ¥æ”¶
  95   3                                      receiveBuff[receiveCounter] = SBUF;
  96   3                                      receiveCounter++ ;
  97   3                                      break;
  98   3                              case 4:                                                                                 //å¦‚æœæ˜¯ç¬¬5ä½ç›´æ¥æ¥æ”¶
  99   3                                      receiveBuff[receiveCounter] = SBUF;
 100   3                                      receiveCounter++ ;
 101   3                                      break;
 102   3                              case 5:                                                                                 //å¦‚æœæ˜¯ç¬¬6ä½ï¼Œè¿›è¡Œåè®®ç¡®è®¤ï¼Œè‹¥åè®®é”™è¯¯ï¼Œä¸ä»…æ”¾å¼ƒè¿˜è¦å‘é€é
             -”™è¯¯æŠ¥å‘Š
 103   3                                      if (SBUF == 0xAA)
 104   3                                      {
 105   4                                              receiveBuff[receiveCounter] = SBUF;
 106   4                                              receiveCounter++ ;
 107   4                                      }
 108   3                                      else
 109   3                                      {
 110   4                                              SBUF = sendBuff[sendCounter] ;
 111   4                                              receiveCounter = 0 ;//æ”¾å¼ƒæ­¤æ¬¡æ¥æ”¶æ•°æ®
 112   4                                              sendCounter++ ;
 113   4                                      }
C51 COMPILER V9.01   MAIN                                                                  01/07/2019 15:52:55 PAGE 3   

 114   3                                      break;
 115   3                              case 6:                                                                                 //å¦‚æœæ˜¯ç¬¬7ä½, è¿›è¡Œæ ¡éªŒç æ£€æŸ¥       
 116   3                                      if(SBUF == getCheckCode(1))                                     //è¿›è¡Œæ¥å—æ£€éªŒç æ£€æŸ¥
 117   3                                      {
 118   4                                              motors1 = receiveBuff[4];                       //ä½å…«ä½æ”¾å…¥motors1
 119   4                                              motors2 = receiveBuff[3];               //é«˜å…«ä½æ”¾å…¥motors2
 120   4                                      }
 121   3                      }
 122   2                      RI = 0;                                                                                         //æ¸…ç©ºRIç­‰å¾…ä¸‹æ¬¡è¢«ä¸­æ–­
 123   2              }
 124   1              else
 125   1              {
 126   2                      switch(sendCounter)
 127   2                      {
 128   3                              case 1:
 129   3                                      SBUF = readSwitch();                                            //è‹¥æ˜¯ç¬¬äºŒä½ï¼Œå‘é€åœ°å€
 130   3                                      sendBuff[sendCounter] = readSwitch();
 131   3                                      sendCounter++ ;
 132   3                                      break;
 133   3                              case 4:                                                                                 //è‹¥æ˜¯ç¬¬äº”ä½ï¼Œå‘é€æ ¡éªŒç 
 134   3                                      SBUF = getCheckCode(0);
 135   3                                      sendCounter++ ;
 136   3                                      break;
 137   3                              default:
 138   3                                      SBUF = sendBuff[sendCounter];
 139   3                                      sendCounter++ ;
 140   3                      }
 141   2                      TI = 0;
 142   2              }
 143   1      }
 144          
 145          /*******************************************************************************
 146          * å‡½æ•°å         : InitTimer0
 147          * å‡½æ•°åŠŸèƒ½           : åˆå§‹åŒ–å®šæ—¶å™¨0
 148          * è¾“å…¥           : æ— 
 149          * è¾“å‡º                 : æ— 
 150          *******************************************************************************/
 151          void InitTimer0()
 152          {
 153   1              EA = 1;                     //æ‰“å¼€ä¸­æ–­æ€»å¼€å…³
 154   1              ET0 = 1;                        //å…è®¸å®šæ—¶å™¨0çš„ä¸­æ–­
 155   1              TMOD=0X21;                      //è®¾ç½®å®šæ—¶å™¨0ä¸ºå·¥ä½œæ–¹å¼1
 156   1      
 157   1              TH0=0XCD;                       //è®¾ç½®å®šæ—¶çš„æ—¶é•¿ä¸º1ms
 158   1              TL0=0XD4;                       
 159   1              TR0=1;                          //å¼€å§‹å®šæ—¶  
 160   1      }
 161          
 162          
 163          /*******************************************************************************
 164          * å‡½æ•°å         :readSwitch
 165          * å‡½æ•°åŠŸèƒ½           : è¯»å–æ‹¨ç å¼€å…³çš„è®¾å®šåœ°å€
 166          * è¾“å…¥           : æ— 
 167          * è¾“å‡º                 : è®¤ä¸ºè®¾å®šçš„åœ°å€
 168          *******************************************************************************/
 169          u8 readSwitch()
 170          {       
 171   1              u8 address;
 172   1              address = XBYTE[0x7FFF] ;
 173   1              return address;
 174   1      }
 175          /*******************************************************************************
C51 COMPILER V9.01   MAIN                                                                  01/07/2019 15:52:55 PAGE 4   

 176          * å‡½æ•°å         : getCheckCode()
 177          * å‡½æ•°åŠŸèƒ½           : è·å–æ ¡éªŒç 
 178          * è¾“å…¥           : æ˜¯æ¥å—æ ¡éªŒç è¿˜æ˜¯å‘é€æ ¡éªŒç ï¼Œæ¥æ”¶æ ¡éªŒä¸º1ï¼Œå‘é€æ ¡éªŒä¸º0
 179          * è¾“å‡º                 : æ ¡éªŒç 
 180          *******************************************************************************/
 181          u8 getCheckCode(u8 receive_or_send)
 182          {
 183   1              u8 result = 0x00, i;    
 184   1              if( receive_or_send == 1)
 185   1              {
 186   2                      for (i=0; i<6; i++)
 187   2                      {       
 188   3                              result += receiveBuff[i] ;
 189   3                      }
 190   2              }
 191   1              else
 192   1              {
 193   2                      for (i=0; i<4; i++)
 194   2                      {
 195   3                              result += sendBuff[i] ;
 196   3                      };
 197   2              }
 198   1              return result; 
 199   1      
 200   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    320    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
